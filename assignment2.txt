Class Diagrams
----------------------------------------------------------------------
class Node
	
	#Ruby is has no variable type so any type of data member can be
	# assigned to value

	(-) value,Node next
	
	#These methods are automatically generated by ruby using 
	# "attr_accessor :value, :next"
	#Ommitted return type on first two because they can return anything
	# that is assigned to them.
	#value=() can be called with "node.value = some_value" 
	# beacause of ruby
	
	(+) value()
	(+) next()
	(+) void value=(data_type variable)
	(+) void next=(Node next)

	(+)void Node(val)

class LinkedList
	(-)Node head, tail
	(+)Node head() #Getter functions created by attr_reader :head,:tail
	(+)Node tail()
	
	#Ruby doesnt allow overloading so you must use other techniques to
	# achieve this outcome using one function, but it is the same 
	# result

	(+)void LinkedList(int size = nil)
	(+)void LinkedList(int size = nil, Node node)
	(+)void LinkedList(int size = nil, LinkedList cpy)

	(+)void purge()
	(+)void empty?()
	(+)Node first()
	(+)Node last()
	(+)void delete_top
	(+)void ordered_insert(Node data)
	(+)void prepend(Node data)
	(+)void append(Node data)
	(+)int count
	(+)Node search(Node value)
	(+)void each(&block) #implements an iterator service the ruby way
class Stack extends LinkedList
	(+)void Stack(int size = nil)
	(+)void Stack(Node node)
	(+)void push(Node data)
	(+)Node pop()
	(+)Node top()
class Queue extends LinkedList
	(+)void Queue(int size = nil)
	(+)void Queue(Node data)
	(+)void enqueue(Node data)
	(+)Node dequeue()
	(+)Node top()

Main Psuedocode
	1.Call linked list report function
		i. Initialize linked list.
		ii. Populate with values.
		iii. Print expexted output.
		iv. Print actual output.
	2. Call ordered linked list report function
		i. Initialize ordered linked list.
		ii. Populate with values.
		iii. Print expexted output.
		iv. Print actual output.
	3. Call stack report function
		i. Initialize stack.
		ii. Populate with values.
		iii. Print expexted output.
		iv. Print actual output.
	4. Call queue report function
		i. Initialize queue.
		ii. Populate with values.
		iii. Print expexted output.
		iv. Print actual output.
	5. End of program.

Source code
----------------------------------------------------------------------

class Node
	
	attr_accessor :value,:next,:previous
	include Comparable

	def initialize(val)
		@value = val
		@next = nil
	end
	
end
----------------------------------------------------------------------
require_relative "Node.rb"
class LinkedList
	#Shows the beginins and end node of the linked list
	attr_reader :head,:tail
	#Structure to define a slot data type
	
	#Initialize an empty Linked list
	def initialize size = nil, node = nil
		@count = 0
		@size = size
		if node == nil
			@head = nil
			@tail = nil
		else
			@head = node
			current = @head
			until current == nil
				if current.next == nil
					@tail = current
				end
				current = current.next
			end
		end
	end
	#Empties the linked list 
	def purge 
		@head = nil
		@tail = nil
	end
	#Returns boolean value showing if the list is empty or not 
	def empty?
		@head.nil?
	end
	def full?
		return false if @size.nil? or @count < @size
		return true if @count >= @size
	end

	#Returns the first value in the list
	def first
		raise "ContainerEmpty" if @head.nil?
		@head
	end
	def last
		raise "ContainerEmpty" if @head.nil?
		@tail
	end
	def delete_top
		@head = @head.next
		@count -= 1
	end
	def delete_bottom
		@tail = @tail.previous
		@tail.next = nil
		@count -= 1
	end
	def ordered_insert(data)
		
		if self.empty?
			self.prepend(data)
		else
			tmp = Node.new(data)
			current = @head
			if tmp.value <= @head.value
				self.prepend(data)
				return
			elsif tmp.value >= @tail.value
				self.append(data)
				return
			end
			until current.nil?
				if tmp.value <= current.next.value
					tmp.next = current.next
					tmp.previous = current
					current.next.previous = tmp
					current.next = tmp
					return
					@count += 1
				end
				current = current.next
			end
		end
	end


	#Adds a bucket or adds to a current bucket in the list
	def prepend(data)
		tmp = Node.new(data)
		if @head.nil?
			@head = tmp
			@tail = tmp
		else 
			tmp.next = @head
			tmp.previous = nil
			@head.previous = tmp
			@head = tmp
		end
		@count += 1

	end
		#tmp (insert tmp info here)
	def append(data)
		tmp = Node.new(data)
		if @head.nil?
			@head = tmp
			@tail = tmp
			
		else
			@tail.next = tmp
			tmp.previous = @tail
			tmp.next = nil
			@tail = tmp
		end
		@count += 1
	end
	def count 
		count = 0
		each {|node| count += 1 }
		count
	end
	def search(value)
		each {|node| return true if node == value}
		false
	end

	# Iterate through the current list and preform actions on the data in a code block
	def each
		current = @head
		while current != nil
			yield current.value
			current = current.next
		end
	end
end
----------------------------------------------------------------------

require_relative "LinkedList.rb"
class Stack < LinkedList

	def initialize size = nil
		super size
	end

	def push(data)
		prepend(data)
	end
	def pop
		raise "StackEmpty" if empty?
		tmp = first
		delete_top
		tmp
	end
	def top 
		first
	end
end
----------------------------------------------------------------------
require_relative "LinkedList.rb"

class MyQueue < LinkedList

	def initialize size = nil
		super size
	end
	
	def enqueue(data)
		append(data)
	end
	
	def dequeue
		raise "QueueEmpty" if empty?
		tmp = first
		delete_top
		tmp
	end
	def top 
		first
	end

end
----------------------------------------------------------------------
#AppDriver.rb

require "./LinkedList.rb"
require "./Stack.rb"
require "./Queue.rb"
$stdout.reopen("report.txt","w")

def main
	linked_list_report
	ordered_linked_list_report
	stack_report
	queue_report
end

def linked_list_report
	puts "Linked List Report\n\n".rjust(25)
	ll = LinkedList.new(6)
	ll.prepend("Hello")
	ll.append("World!")
	ll.prepend("Demonstrating")
	ll.append("For my linked list.")
	ll.prepend("This is a test entry")
	ll.append("Item 6")
	puts <<-EOS.gsub /^\s+/, ""
		Expected:
		This is a test entry
		Demonstrating
		Hello
		World!
		For my linked list.
		Item 6
	EOS
	puts
	puts "Is this list full? #{ll.full?}" 
	puts "Is this list empty? #{ll.empty?}"
	puts
	puts "Actual:"
	ll.each{|string| puts string}
	ll.delete_top
	ll.delete_bottom
	ll.append("Two items have been deleted")
	ll.delete_top
	ll.prepend("The first three are now missing")
	puts
	puts "Is this list full? #{ll.full?}" 
	puts "Is this list empty? #{ll.empty?}"
	puts
	puts "After delete and insert:"
	ll.each{|node| puts node}
	puts
end

def ordered_linked_list_report
	puts "Ordered Linked List Report\n\n".rjust(30)
	oll = LinkedList.new
	oll.ordered_insert(55)
	oll.ordered_insert(10)
	oll.ordered_insert(-2)
	oll.ordered_insert(553)
	oll.ordered_insert(23)
	oll.ordered_insert(8)
	oll.ordered_insert(-96)
	puts <<-EOS.gsub /^\s+/, ""
		Expexted:
		-96
		-2
		8
		10
		23
		55
		553
	EOS
	puts
	puts "Is this list full? #{oll.full?}" 
	puts "Is this list empty? #{oll.empty?}"
	puts
	puts "Actual:"
	oll.each{|num| puts num}
	oll.delete_bottom
	oll.delete_top
	oll.ordered_insert(-10)
	oll.ordered_insert(823)
	oll.ordered_insert(28)
	puts
	puts "Is this list full? #{oll.full?}" 
	puts "Is this list empty? #{oll.empty?}"
	puts
	puts "Ordered linked list after insertions and deletions"
	oll.each{|num| puts num}
	puts
end

def stack_report
	st = Stack.new(6)
	st.push("First entry")
	st.push("Second entry")
	st.push("Third entry")
	st.push("Fourth entry")
	st.push("Fifth entry")
	st.push("Last entry")
	puts "Stack Report\n\n".rjust(20)
	puts
	puts "Is this stack full? #{st.full?}" 
	puts "Is this stack empty? #{st.empty?}"
	puts
	puts <<-EOS.gsub /^\s+/, ""
			Expected:
			Last entry
			Fifth entry
			Fourth entry
			Third entry
			Second entry
			First entry
		EOS
	puts
	puts "Actual:"
	st.each{|val| puts val}
	puts
	puts "Pop 1: #{st.pop.value}"
	puts "Pop 2: #{st.pop.value}"
	puts "Pop 3: #{st.pop.value}"
	st.push("First new entry")
	st.push("Second new entry")
	puts
	puts "Is this stack full? #{st.full?}" 
	puts "Is this stack empty? #{st.empty?}"
	puts
	puts "Actual after pop and push:"
	until st.empty?
		puts st.pop.value
	end
	puts
	puts "Is this stack empty? #{st.empty?}"
	puts
end

def queue_report
	q = MyQueue.new
	q.enqueue([1, 2, 3])
	q.enqueue([4, 5, 6])
	q.enqueue([7, 8, 9])
	q.enqueue([10, 11, 12])
	q.enqueue([13, 14, 15])
	q.enqueue([16, 17, 18])
	puts "Queue Report\n\n".rjust(20)
	puts <<-EOS.gsub /^\s+/, ""
			Expected:
			[1, 2, 3]
			[4, 5, 6]
			[7, 8, 9]
			[10, 11, 12]
			[13, 14, 15]
			[16, 17, 18]
		EOS
	puts
	puts "Is this queue full? #{q.full?}" 
	puts "Is this queue empty? #{q.empty?}"
	puts
		puts "Actual Before Dequeue:"
		q.each do |node|
			puts node.to_s
		end
		puts
		puts "Dequeue 1: #{q.dequeue.value.to_s}"
		puts "Dequeue 2: #{q.dequeue.value.to_s}"
		puts
		puts "Actual After Dequeue:"
		q.each do |node|
			puts node.to_s
		end
	puts
	puts "Is this queue full? #{q.full?}" 
	puts "Is this queue empty? #{q.empty?}"
	puts
end
main
----------------------------------------------------------------------
report.txt
----------------------------------------------------------------------
     Linked List Report

Expected:
This is a test entry
Demonstrating
Hello
World!
For my linked list.
Item 6

Is this list full? true
Is this list empty? false

Actual:
This is a test entry
Demonstrating
Hello
World!
For my linked list.
Item 6

Is this list full? false
Is this list empty? false

After delete and insert:
The first three are now missing
Hello
World!
For my linked list.
Two items have been deleted

  Ordered Linked List Report

Expexted:
-96
-2
8
10
23
55
553

Is this list full? false
Is this list empty? false

Actual:
-96
-2
8
10
23
55
553

Is this list full? false
Is this list empty? false

Ordered linked list after insertions and deletions
-10
-2
8
10
23
28
55
823

      Stack Report


Is this stack full? true
Is this stack empty? false

Expected:
Last entry
Fifth entry
Fourth entry
Third entry
Second entry
First entry

Actual:
Last entry
Fifth entry
Fourth entry
Third entry
Second entry
First entry

Pop 1: Last entry
Pop 2: Fifth entry
Pop 3: Fourth entry

Is this stack full? false
Is this stack empty? false

Actual after pop and push:
Second new entry
First new entry
Third entry
Second entry
First entry

Is this stack empty? true

      Queue Report

Expected:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10, 11, 12]
[13, 14, 15]
[16, 17, 18]

Is this queue full? false
Is this queue empty? false

Actual Before Dequeue:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10, 11, 12]
[13, 14, 15]
[16, 17, 18]

Dequeue 1: [1, 2, 3]
Dequeue 2: [4, 5, 6]

Actual After Dequeue:
[7, 8, 9]
[10, 11, 12]
[13, 14, 15]
[16, 17, 18]

Is this queue full? false
Is this queue empty? false

